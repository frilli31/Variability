% Use only LaTeX2e, calling the article.cls class and 12-point type.

\documentclass[12pt]{article}

% Users of the {thebibliography} environment or BibTeX should use the
% scicite.sty package, downloadable from *Science* at
% www.sciencemag.org/about/authors/prep/TeX_help/ .
% This package should properly format in-text
% reference calls and reference-list numbers.

\usepackage{scicite}

% Use times if you have the font installed; otherwise, comment out the
% following line.

%\usepackage{times}

% The preamble here sets up a lot of new/revised commands and
% environments.  It's annoying, but please do *not* try to strip these
% out into a separate .sty file (which could lead to the loss of some
% information when we convert the file to other formats).  Instead, keep
% them in the preamble of your main LaTeX source file.


% The following parameters seem to provide a reasonable page setup.

\topmargin 0.0cm
\oddsidemargin 0.2cm
\textwidth 16cm 
\textheight 21cm
\footskip 1.0cm


%The next command sets up an environment for the abstract to your paper.

\newenvironment{sciabstract}{%
\begin{quote} \bf}
{\end{quote}}


% If your reference list includes text notes as well as references,
% include the following line; otherwise, comment it out.

\renewcommand\refname{References and Notes}

% The following lines set up an environment for the last note in the
% reference list, which commonly includes acknowledgments of funding,
% help, etc.  It's intended for users of BibTeX or the {thebibliography}
% environment.  Users who are hand-coding their references at the end
% using a list environment such as {enumerate} can simply add another
% item at the end, and it will be numbered automatically.

\newcounter{lastnote}
\newenvironment{scilastnote}{%
\setcounter{lastnote}{\value{enumiv}}%
\addtocounter{lastnote}{+1}%
\begin{list}%
{\arabic{lastnote}.}
{\setlength{\leftmargin}{.22in}}
{\setlength{\labelsep}{.5em}}}
{\end{list}}


% Include your paper's title here

\title{
		\includegraphics[scale=0.20]{logo-unipd}~ 
		\\[2cm]
		Report of {\it Process Mining\/} project
	} 


% Place the author information here.  Please hand-code the contact
% information and notecalls; do *not* use \footnote commands.  Let the
% author contact information appear immediately below the author names
% as shown.  We would also prefer that you don't change the type-size
% settings shown here.

\author
{Luca Allegro 1211142 \\ Alberto Bezzon 1211016\\
\\
Department of Science (Computer Science), University of Padua
}

% Include the date command, but leave its argument blank.

\date{}



%%%%%%%%%%%%%%%%% END OF PREAMBLE %%%%%%%%%%%%%%%%

% My packages
\usepackage{graphicx}
\usepackage{minted}

\graphicspath{ {./images/} } 
%\usemintedstyle[python]{monokai}

\begin{document} 

% Double-space the manuscript.

\baselineskip18pt

% Make the title.

\maketitle 



% Place your abstract within the special {sciabstract} environment.

\begin{sciabstract}
  This document aims to describe the procedure adopted to solve \textit{Project 1: How much variable is my event log?}
  (probabilmente da rimuovere)
\end{sciabstract}



% In setting up this template for *Science* papers, we've used both
% the \section* command and the \paragraph* command for topical
% divisions.  Which you use will of course depend on the type of paper
% you're writing.  Review Articles tend to have displayed headings, for
% which \section* is more appropriate; Research Articles, when they have
% formal topical divisions at all, tend to signal them with bold text
% that runs into the paragraph, for which \paragraph* is the right
% choice.  Either way, use the asterisk (*) modifier, as shown, to
% suppress numbering.

\newpage
\section*{Introduction}

This report has the aim of summarize the Process Mining project. In this project we aim at measuring how much variable are event logs, in terms of variety of behavior. Computing the variability of a log can indeed be rather useful, for instance, to decide for (a procedural or a declarative) model discovery, or to decide which prediction technique to apply. The are a lot of different ways to measure the variability of an event log, three of them are described in the following section.

A possible way to measure the variability of an event log is counting the number of variants that it contains. A second possibility is to average the edit distance between each pair of traces in the event log. 

The present report contributes (1) 


\section*{Project description}

\subsection*{First approach}

The first and easiest way to measure variability of an event log is counting the number of variants that it contains. Recall the definition of process variant, that is a sequence of process activities, the following fuctions does that we just described:


\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{python}
	def compute_variant_variability(log: lg.EventLog) -> int:
	"""Compute the number of variants present in the event log
	
	Args:
	log (lg.EventLog): The log to examine
	
	Returns:
	int: The number of variants present in the event log
	"""
	# For each case of the log we construct a tuple with the names of events.
	# Then we collect all of them in a set to remove duplicates.
	# Eventually we compute the length of the set.
	return len(set(tuple(event["concept:name"] for event in case) for case in log))
\end{minted}


\noindent This way is the simplest and intuitive way to compute log variability. However, this metrics does not consider the size of the log, i.e. big size logs are penalized w.r.t. small size log. Another reason why this way is unhelpful to our goal is that it does not consider how variants differ to one another.


\section*{Second approach}

The second approach is to average the edit distance between each pair of traces in the event log. For this purpose, we decided to use the Levenshtein distance. Levenshtein edit distance is the most well-known string edit distance metric and is defined by the number of insertions, deletions and substitutions required to convert one string into another. The basic idea to compute average edit distance: first we computed the sum of edit distance of all possible combination of two pair of traces and then we divided by the number of possible combination that is (\textit{size\_of\_log * (size\_of\_log - 1)}).

\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{python}
def compute_edit_distance_variability(log: lg.EventLog) -> float:
"""Compute the average edit distance (Levenshtein distance) between each
pairs of traces.

This function uses function `eval` of module 'editdistance' because it's
implemented in C++ and it is faster than the corresponding implementation
in python.

Args:
log (EventLog): The log to examine

Returns:
float: the average edit distance between each pairs of traces
"""
# Create a dictionary which contains variants as keys and its number of
# occurrences as values
variants_and_counts = Counter(
tuple(event["concept:name"] for event in case) for case in log
)
size_of_log = len(log)

# For each pair of distinct variants (obtained by 'combinations') we
# compute the edit distance and we multiply it for number of
# occurrences of the variants.
# In the end we sum all of them.
sum_of_distances = sum(
num_of_items_1 * num_of_items_2 * editdistance.eval(variant1, variant2)
for (variant1, num_of_items_1), (variant2, num_of_items_2)
in combinations(variants_and_counts.items(), 2)
)

# We multiply the sum of distances by 2 because to add the sum of distances
# of each inverted pairs of variants.
# In the end we divide it by the number of possible combination of pair
# of traces
return float(sum_of_distances * 2) / (size_of_log * (size_of_log - 1))
\end{minted}

This method has two main advantages: the first is that it takes into account the size of the log and the second is that it consider variants frequencies.

Some important caveats are:
\begin{itemize}
	\item in the first rows of the function, we use variants instead of traces because we calculate the edit distance of two different traces multiplied by the n (number of repetition of a trace) instead of calculate edit distance between two traces n times.
	\item (line combination) method combination of the library itertools provide the combination of two different variants; the only case not covered is when two traces belong to the same variant. But, in this case, the edit distance is 0 so it does not affect the result.
	\item To optimize the calculation of edit distance, we use a C++ library with API for python because the above function has high complexity and with very big log (e.g. BPIchallenge2011.xes) it takes very long time.
\end{itemize}

This method also has the following disadvantages: since it has a high complexity, it is very time-consuming for some large log and it does not consider the length of each traces and the variance. Indeed, logs with longest traces and high variance of length are penalized. (insert example of log).

We have tried another edit distance metric, that is Damerau-Levenshtein edit distance. This distance is similar to Levenshtein edit distance with the addition of another possibly operation (transposition of two adjacent characters) to convet a string into another. This metric performs better than Levenshtein distance only in the case where two traces differs only by order of events at distance one.

\section*{Third approach}

To address the weakness of edit distance, we developed a third way that consist in normalization of edit distance.  We normalise edit distance by the greatest possible distance between the traces to reflect that a distance of one operation on two very long strings should be considered less significant than on very short strings. In this way, we are able to compare the result with logs with a different average length.
\begin{minted}[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]{python}
def compute_my_variability(log: lg.EventLog) -> float:
"""Compute the average of normalized edit distances (Levenshtein distance)
between each pairs of traces.

This function uses function `eval` of module 'editdistance' because it's
implemented in C++ and it is faster than the corresponding implementation
in python.

Args:
log (EventLog): The log to examine

Returns:
float: a number between 0 and 1 included. The higher the number the
more similar the traces are
- 0 : if all traces has nothing in common
- 1 : all traces belongs to the same variant (are equals)
"""
# Create a dictionary which contains variants as keys and its number of
# occurrences as values
variants_and_counts = Counter(
tuple(event["concept:name"] for event in case) for case in log
)
size_of_log = len(log)

# For each pair of distinct variants (obtained by 'combinations') we
# compute the average edit distance normalized (divided by longest trace)
# and we multiply it for number of occurrences of the variants.
# In the end we sum all of them.
sum_of_distances = sum(
float(num_of_items_1 * num_of_items_2 * editdistance.eval(variant1, variant2))
/ max(len(variant1), len(variant2))
for (variant1, num_of_items_1), (variant2, num_of_items_2)
in combinations(variants_and_counts.items(), 2)
)

# We multiply the sum of distances by 2 because to add the sum of distances
# of each inverted pairs of variants
# In the end we divide it by the number of possible combination of pair
# of traces
return 1 - (sum_of_distances * 2 / (size_of_log * (size_of_log - 1)))
\end{minted}

This metric produces a result in the range [0, 1], that is immediatly interpretable because it represent the fraction of how traces are equals.


\section*{BPI Challenge 2011}

At first we compute \texttt{compute\_variant\_variability} 981 

\begin{itemize}
	\item we have lots of differents variants, nothing else. Only computing the size of the log (1143) we view that most of traces are differt one another
\end{itemize}

Then we compute \texttt{compute\_edit\_distance\_variability}

\begin{itemize}
	\item 195.88194492325937\\
	It seems very high. You cannot undarstand if traces have something in common.
\end{itemize}

Compute my variability

\begin{itemize}
	\item 0.14258102346211654: average 15\% in common, not so much. It gives us more information than the others. We can say that this log has high variability....
\end{itemize}

\section*{Instructions}

\begin{enumerate}
	\item Extract 'Progetto.zip'
	\item Open a terminal inside the folder
	\item Install requirements usign command: \texttt{pip install requirements.txt}
	\item Run the tests using: \texttt{pytest}
	\item In file 'main.py' you can find an use example and you can run it: \texttt{python main.py}
\end{enumerate}

\bibliography{scibib}

\bibliographystyle{Science}



% Following is a new environment, {scilastnote}, that's defined in the
% preamble and that allows authors to add a reference at the end of the
% list that's not signaled in the text; such references are used in
% *Science* for acknowledgments of funding, help, etc.

\begin{scilastnote}
\end{scilastnote}




% For your review copy (i.e., the file you initially send in for
% evaluation), you can use the {figure} environment and the
% \includegraphics command to stream your figures into the text, placing
% all figures at the end.  For the final, revised manuscript for
% acceptance and production, however, PostScript or other graphics
% should not be streamed into your compliled file.  Instead, set
% captions as simple paragraphs (with a \noindent tag), setting them
% off from the rest of the text with a \clearpage as shown  below, and
% submit figures as separate files according to the Art Department's
% instructions.


\clearpage

%\noindent {\bf Fig. 1.} Please do not use figure environments to set
up your figures in the final (post-peer-review) draft, do not include graphics in your
source code, and do not cite figures in the text using \LaTeX\
\verb+\ref+ commands.  Instead, simply refer to the figure numbers in
the text per {\it Science\/} style, and include the list of captions at
the end of the document, coded as ordinary paragraphs as shown in the
\texttt{scifile.tex} template file.  Your actual figure files should
be submitted separately.



\end{document}




















